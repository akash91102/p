// Add this method to ensure proper state synchronization
componentDidUpdate(prevProps) {
    // Only process if we have new data from props and it's different from previous
    if (prevProps.data !== this.props.data && this.props.data) {
        const newMasterAgreements = this.getCurrentMasterAgreements();
        const validNewAgreements = Array.isArray(newMasterAgreements) ? newMasterAgreements : [];

        // Update grid if the data has actually changed
        if (this.gridApiRefs["masterAgreements"]) {
            const currentGridData = [];
            this.gridApiRefs["masterAgreements"].forEachNode(node => {
                currentGridData.push(node.data);
            });

            // Only update grid if data is different
            if (JSON.stringify(validNewAgreements) !== JSON.stringify(currentGridData)) {
                this.gridApiRefs["masterAgreements"].setRowData([...validNewAgreements]);
            }
        }

        // Clear selected rows when data changes from external source
        this.setState({ selectedRows: [] });
    }
}

// Modified setup method to avoid re-processing existing masterAgreements
setup = (config) => {
    let cloneData = cloneObject(this.props.data || {});
    
    // Check if masterAgreements already exist to avoid overwriting user changes
    const existingMasterAgreements = this.getCurrentMasterAgreements();
    const hasExistingMasterAgreements = Array.isArray(existingMasterAgreements) && existingMasterAgreements.length > 0;
    
    // Only process inScope data if no masterAgreements exist yet
    if (!hasExistingMasterAgreements) {
        this.handleOnInsertInScopeMasterAgreementsList(cloneData);
    }
    
    this.handleOnInsertInECPAndSPN(cloneData);

    let configSetupVar = configSetup({
        config,
        formdata: cloneData,
        staticData: this.props.staticData,
        bindFunctions: this.bindedEvents,
    });

    this.setState({ config: configSetupVar });

    if (this.props.onCustFormUpdate) {
        this.props.onCustFormUpdate(cloneData);
    }
};

// Enhanced updateMasterAgreements method with better persistence
updateMasterAgreements = (newAgreements, callback = null) => {
    const agreementsArray = Array.isArray(newAgreements) ? newAgreements : [];

    let formData = cloneObject(this.props.data || {});
    this.initializeProfileData(formData);

    const prop = 'compositeProfile.legalAgreement.attributes.masterAgreements';

    // Ensure the path exists
    if (traverseObjectAndReturn({obj: formData, string: prop}) === null) {
        traverseObjectAndInsert({
            obj: formData, 
            string: prop, 
            bindOn: 'masterAgreements',
            newValues: {
                source: 'USER',
                sourceId: this.props.userInfo?.username || 'system',
                value: []
            }
        });
    }

    let masterAgreementsObj = traverseObjectAndReturn({obj: formData, string: prop});
    if (!masterAgreementsObj) {
        masterAgreementsObj = {
            source: 'USER',
            sourceId: this.props.userInfo?.username || 'system',
            value: []
        };
    }

    // Update the agreements
    masterAgreementsObj.value = [...agreementsArray];
    masterAgreementsObj.source = 'USER';
    masterAgreementsObj.sourceId = this.props.userInfo?.username || 'system';

    traverseObjectAndInsert({
        obj: formData,
        string: prop,
        bindOn: 'masterAgreements',
        newValues: masterAgreementsObj
    });

    // Force update parent state immediately
    if (this.props.onCustFormUpdate) {
        this.props.onCustFormUpdate(formData);
    }

    // Update grid after a short delay to ensure state is updated
    setTimeout(() => {
        if (this.gridApiRefs["masterAgreements"]) {
            this.gridApiRefs["masterAgreements"].setRowData([...agreementsArray]);
        }
    }, 100);

    if (callback) callback();
};

// Add state persistence tracking
constructor(props) {
    super(props);

    // ... existing constructor code ...

    // Add state tracking
    this.state = {
        ...this.state,
        hasLocalChanges: false,
        lastSavedData: null,
        isInitialized: false
    };
}

// Modified componentDidMount to track initialization
componentDidMount() {
    try {
        const config = fetchConfig(this.props.appState?.lob || "xm");
        this.setup(config);
    } catch (error) {
        console.error('Failed to fetch config:', error);
        const fallbackConfig = {
            layout: [
                {
                    refKey: "agreement",
                    header: { title: "XM Profile Information" },
                    type: "form",
                    data: [],
                },
            ],
            create: {
                newMasterAgreements: {
                    data: [{ column: [] }]
                }
            }
        };
        this.setup(fallbackConfig);
    }

    this.setState({
        hasLocalChanges: false,
        lastUpdateTimestamp: null,
        isInitialized: true
    });
}

// Add method to check if data needs to be preserved
shouldPreserveLocalChanges = () => {
    const currentAgreements = this.getCurrentMasterAgreements();
    const { lastSavedData } = this.state;
    
    if (!lastSavedData) return false;
    
    return JSON.stringify(currentAgreements) !== JSON.stringify(lastSavedData);
};

// Enhanced modal save handler
onSave: async () => {
    this.setState({ resetTable: true }, async () => {
        try {
            // ... existing validation code ...

            if (!exists) {
                let updatedAgreements = [...currentAgreements];

                if (isEditMode) {
                    // ... existing edit logic ...
                } else {
                    // ... existing add logic ...
                }

                this.toggleModal({ state: false });

                // Update with callback to ensure persistence
                this.updateMasterAgreements(updatedAgreements, () => {
                    this.setState({ 
                        resetTable: false, 
                        selectedRows: [],
                        hasLocalChanges: true,
                        lastSavedData: [...updatedAgreements]
                    });
                    this.rebuildCrossMarginEntities(updatedAgreements);
                });
            } else {
                this.setState({ resetTable: false });
            }

        } catch (error) {
            // ... existing error handling ...
        }
    });
}
